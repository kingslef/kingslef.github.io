<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Aatos Jalo]]></title>
  <link href="https://www.aatosjalo.com/blog/categories/programming/atom.xml" rel="self"/>
  <link href="https://www.aatosjalo.com/"/>
  <updated>2016-04-02T12:32:28+03:00</updated>
  <id>https://www.aatosjalo.com/</id>
  <author>
    <name><![CDATA[Aatos Jalo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Creating a NES emulator]]></title>
    <link href="https://www.aatosjalo.com/blog/2015/05/31/developing-own-nes-emulator/"/>
    <updated>2015-05-31T21:24:35+03:00</updated>
    <id>https://www.aatosjalo.com/blog/2015/05/31/developing-own-nes-emulator</id>
    <content type="html"><![CDATA[<p>I read an
<a href="https://medium.com/@fogleman/i-made-an-nes-emulator-here-s-what-i-learned-about-the-original-nintendo-2e078c9b28fe">interesting post</a>
about NES internals and its emulation and I immediately wanted to create my own
emulator. There is already great documentation about NES, so I will be only writing about
my process and giving some links to learn more.</p>

<!-- more -->


<p>I started by trying to understand the 6502
assembly. <a href="http://nesdev.com/6502guid.txt">This</a> gives nice overview on 6502
instructions and registers. <a href="http://nesdev.com/">NesDev</a> has also some other nice
(but apparently outdated) guides.</p>

<p>Next I went to learn about NES programming and I found a good
<a href="http://nintendoage.com/forum/messageview.cfm?catid=22&amp;threadid=7155">tutorial</a>. It
explains quite nicely how to interact with the picture processing unit (PPU),
how the ROM is partitioned and so on. Some details are on a quite high level, so
more info can be found e. g. in
<a href="http://wiki.nesdev.com/w/index.php/NES_reference_guide">NesDev Wiki</a>. For
instance, the <a href="http://wiki.nesdev.com/w/index.php/PPU_registers">PPU registers</a>
are explained in much more depth.</p>

<p>I found an <code>bmp2chr</code> converter
(<a href="http://bobrost.com/nes/files/nes_sprite_tools_2004_03_18.zip">sources here</a>),
so I managed to create my own sprites. First I drew tile map as BMP using
<a href="http://www.aseprite.org/">Asprite</a>, then converted that to CHR. As an
assembler, I used <code>nesasm3</code>
(<a href="http://www.nespowerpak.com/nesasm/nesasmsrc.zip">sources</a>). Windows binaries
were quite easy to come by, but sources (for example using in Linux) were a bit
harder. For emulating first trials, I used
<a href="http://www.fceux.com/web/download.html">FCEUX Win</a>. There are many
cross-platform emulators, but I found debugger only in Windows version of
<code>FCEUX</code>, so I had to use Wine for that.</p>

<p><img src="/images/posts/helloworld.gif" title="My first ROM!" ></p>

<p>At this point I created two simple NES ROMs. First one had few sprites moving
across the screen (above), and the second one was a two-player pong game
(below). Sources can be found in
<a href="https://bitbucket.org/aatos/nes-demos/src">Bitbucket</a> (those could be
improved - to say the least).</p>

<p><img src="/images/posts/pong.gif" title="Pong game" ></p>

<p>I decided not to handle sounds at this point, so now I was ready for starting
the emulator itself. After reading the
<a href="http://wiki.nesdev.com/w/index.php/INES">header</a>, I started handling the
<a href="http://www.obelisk.demon.co.uk/6502/reference.html">opcodes</a>. Fast-forward
some time and I was able to even draw some sprites to the screen!</p>

<p><img src="/images/posts/simpler.png" title="First ROM emulated" ></p>

<p>There is still much to do, but the sources can be found from
<a href="https://bitbucket.org/aatos/6502-emulator/src">here</a> (requires <code>clang</code> and
<code>SFML</code> for the build, and <code>gmock</code> and <code>gtest</code> for the tests).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GCC Extensions]]></title>
    <link href="https://www.aatosjalo.com/blog/2015/04/04/gcc-extensions/"/>
    <updated>2015-04-04T17:58:21+03:00</updated>
    <id>https://www.aatosjalo.com/blog/2015/04/04/gcc-extensions</id>
    <content type="html"><![CDATA[<p>I have been using GCC quite much, but I haven&rsquo;t really ever used its extensions
(except some C99 features in C90). Recently, I stumbled upon the documentation
of all the
<a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">extensions</a>,
so I figured to list few of the special ones here.</p>

<!-- more -->


<h2>Function overloading</h2>

<p>By using <code>__typeof__</code> and <code>__builtin_types_compatible_p(type1, type2)</code>, it is
possible to (kinda) overload functions in C. Let&rsquo;s say for example that you want
to implement <code>is_equal</code> function, which would work on integers and strings. By
using <code>__builtin_types_compatible_p</code> you could check what type the given
parameter is, and then call the appropriate function.</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define is_equal(x, y)                                              \
    do {                                                            \
        if (__builtin_types_compatible_p(__typeof__ (x), char[]))   \
            is_equal_string(x, y);                                  \
        else if (__builtin_types_compatible_p(__typeof__ (x), int)) \
            is_equal_int(x, y);                                     \
    } while (0)

void is_equal_string(const char * x, const char * y)
{
    printf("%s: '%s' and '%s' are %sthe same\n",
           __func__, x, y, strcmp(x, y) != 0 ? "not " : "");
}

void is_equal_int(int x, int y)
{
    printf("%s: '%d' and '%d' are %sthe same\n",
           __func__, x, y, x != y ? "not " : "");
}

int main(void)
{
    is_equal(1, 1);

    is_equal("foo", "foo");

    return 0;
}
</code></pre>

<h2>Cleanup when variable goes out of scope</h2>

<p>With GCC&rsquo;s variable attributes, you can specify a function that is to be called
when the variable goes out of scope. This function receives a pointer to the
parameter, so it can be used e.g. to close a file:</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void cleanup_file(FILE **f)
{
    if (*f) {
        printf("closing file\n");
        fclose(*f);
    }
}

void func(void)
{
    FILE * f __attribute__ ((cleanup(cleanup_file))) = fopen("/dev/null", "w");
    if (!f) {
        return;
    }

    fprintf(f, "test string");
}

int main(void)
{
    func();

    return 0;
}
</code></pre>

<h2>Built-in apply</h2>

<pre><code class="c">void func_without_void();
void func_with_void(void);
</code></pre>

<p>As you may (or may not) know, the function declarations above mean quite
different things in C. The first one accepts any number of arguments (of any
type) and the second one doesn&rsquo;t accept any arguments at all. Hence, first one
could be called as (and compilers should consider it valid):</p>

<pre><code class="c">func_without_void(10);
</code></pre>

<p>but you cannot really access the variable since you don&rsquo;t give it any name (or
even type) in the definition. But here comes <code>__builtin_apply</code> and
<code>__builtin_apply_args</code> to the picture. With <code>__builtin_apply_args</code> you get a
pointer to arguments given to the function and with <code>__builtin_apply(void
(*function)(), void *arguments, size_t size)</code>, you can call a different function
with the arguments. So, for example:</p>

<pre><code class="c">#include &lt;stdio.h&gt;

void func_with_args(int i)
{
    printf("received %d\n", i);
}

void func_without_void()
{
    void* args = __builtin_apply_args();

    __builtin_apply(func_with_args, args, sizeof(int));
}

int main(void)
{
    func_without_void(10);

    return 0;
}
</code></pre>

<p>And it prints:</p>

<pre><code class="sh">$ gcc -std=gnu11 -Wall -Wextra builtin-args.c -o builtin-args
$ ./builtin-args
received 10
</code></pre>

<h2>Extended ASM</h2>

<p>You can easily embed assembly instructions to .c file and even read and write C
variables from assembler (this is quite heavily used in Linux kernel). For
example, if you would like to read the number of CPU cycles since reset, you
could write (on x86):</p>

<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;inttypes.h&gt;

void get_rdtsc(unsigned int * restrict h, unsigned int * restrict l)
{
    __asm__ volatile("rdtsc"
                     : "=a" (*l), "=d" (*h));
}

int main(void)
{
    unsigned int h;
    unsigned int l;

    get_rdtsc(&amp;h, &amp;l);

    printf("rdtsc: %" PRIu64 "\n", (((uint64_t)h) &lt;&lt; 32) | l);

    return 0;
}
</code></pre>

<h2>Nested Functions</h2>

<p>Using GCC, you can actually have functions inside functions.</p>

<pre><code class="c">#include &lt;stdio.h&gt;

int func(int a, int (**func_p)(int))
{
    /* declare with auto */
    auto int func2(int i);

    *func_p = func2;

    int func2(int i)
    {
        // Could use variable a if this function wouldn't be used outside
        return i + 1;
    }

    return func2(5 + a);
}

int main(void)
{
    int (*func_p)(int);

    printf("function with nested function returns %d\n",
           func(5, &amp;func_p));

    printf("nested function returns %d\n",
           func_p(5));

    return 0;
}
</code></pre>

<p>Here, inside <code>func</code>, another function (<code>func2</code>) is first declared and then
defined. Forward-declaration is not necessary here, but in order to do so, you
actually must use <code>auto</code> (this is probably the only place where <code>auto</code> is
needed). <code>func</code> returns a pointer to the nested function so it can also be used
outside of the function (with some restrictions).</p>

<h2>Case ranges</h2>

<p>You can have a range in a switch-case:</p>

<pre><code class="c">void func(int i)
{
    switch (i) {
    case 0 ... 5:
        printf("less than 6\n");
        break;
    default:
        printf("6 or more\n");
        break;
    }
}
</code></pre>

<h2>Forward-declaration of enum</h2>

<p>It is possible to declare an enumeration without specifying its values. There is
not much that can be done with it, but it seems that it was added so enums would
be handled similarly as structs or unions. Before this, I didn&rsquo;t even know it is
forbidden in ISO C.</p>

<pre><code class="c">#include &lt;stdio.h&gt;

enum en;
void func(const enum en e);

enum en {
    FIRST,
    SECOND
};

int main(void)
{
    enum en e = SECOND;

    func(e);

    return 0;
}

void func(enum en e)
{
    printf("enum is %d\n", e);

}
</code></pre>

<p>Complete sources of these examples (and few more) can be found in
<a href="https://github.com/kingslef/gcc-extension-test">github</a>.
Rest of the extensions (and more through documentation of them) can be found
from <a href="https://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html#C-Extensions">GCC docs</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Twitter API with C]]></title>
    <link href="https://www.aatosjalo.com/blog/2015/02/01/using-twitter-api-with-c/"/>
    <updated>2015-02-01T19:01:51+02:00</updated>
    <id>https://www.aatosjalo.com/blog/2015/02/01/using-twitter-api-with-c</id>
    <content type="html"><![CDATA[<p>I wanted once to implement simple twitter integration with one C application.
Even though everything can be found in <a href="https://dev.twitter.com,">https://dev.twitter.com,</a> having no
experience in the API (or OAuth, or OpenSSL), it can take some time to get used
to. Here is a small guide of posting a tweet using C and OpenSSL.</p>

<!-- more -->


<h2>1. Obtain the consumer tokens</h2>

<p>First you&rsquo;ll need consumer key and secret for your twitter application. This
will identify your application to twitter.</p>

<p>To receive keys for your application, you need to create it first at
<a href="https://apps.twitter.com">https://apps.twitter.com</a>. Application will start
with read-only permissions, which you want to change to read and write to be
able to post updates. That will require you to give your phone number to
Twitter.</p>

<p>This will give you keys such as:</p>

<pre><code>consumer key: xvz1evFS4wEEPTGEFPHBog
consumer secret: kAcSOqF21Fu85e7zjz7ZN2U4ZRhfV3WpwPAoE3Z7kBw
</code></pre>

<h2>2. Obtain the access tokens</h2>

<p>These tokens gives your application a permission to post updates on behalf of a
twitter user. Basically the account needs to give permissions for an application
and let it post on its behalf.</p>

<p>There are a few ways to do this. It needs to be done only once per account and
application, so I skipped some corners here: I used <a href="http://www.tweepy.org/">Tweepy</a>
which could generate the tokens quite easily. If you want to do this yourself,
<a href="https://dev.twitter.com/oauth/pin-based">PIN-based authentication</a> would be the way to go.
If the account that you are posting with is the also the owner of the application,
you can also generate the access tokens directly from the application management.</p>

<p>In the end, you should have two keys like this:</p>

<pre><code>access token: k370773112-GmHxMAgYyLbNEtIKZeRNFsMKPR9EyMZeS9weJAEb
access token secret: LswwdoUaIvS8ltyTt5jkRh4J50vUPVVHtR2YPi5kE
</code></pre>

<h2>3. Percent-encode the status</h2>

<p>Let&rsquo;s say that you want to post <code>Hello from Aatosjalo.com!</code>. First the message
needs to be
<a href="http://tools.ietf.org/html/rfc3986#section-2.1">percent-encoded</a>. So all
reserved characters should be transformed to <code>%&lt;byte0&gt;&lt;byte1&gt;</code>, e.g. ASCII
character <code></code> (0x20) is percent-encoded to <code>%20</code>. In C, that could be something
like the following:</p>

<pre><code class="c">/* Does character c need percent-encoding or is it an unreserved character? */
static int need_percent_encoding(char c)
{
    return !(isalnum((int)c) || c == '-' || c == '.' || c == '_' || c == '~');

}

/* Percent-encode (or URL encode) given string. There should be enough room in
 * the str (three times uncoded characters). */
static char *percent_encode(char *str)
{
    for (unsigned int i = 0; str[i] != '\0'; i++) {
        if (need_percent_encoding(str[i])) {
            /* Make room for two characters. */
            memmove(str + i + 3, str + i + 1, strlen(str) - i + 1);
            /* Write '%' and two bytes of which the character consists of. */
            char tmp[2];
            snprintf(tmp, 2, "%X", str[i] &gt;&gt; 4);
            str[i + 1] = tmp[0];
            snprintf(tmp, 2, "%X", str[i] &amp; 0xf);
            str[i + 2] = tmp[0];
            str[i] = '%';
        }
    }

    return str;
}
</code></pre>

<p>Then you should have your status something like:</p>

<pre><code>status: Hello%20from%20Aatosjalo.com%21
</code></pre>

<h2>4. Learn Base 64 Encoding</h2>

<p>Twitter expects a certain signature with each status update that needs to be
<a href="http://tools.ietf.org/html/rfc4648#section-4">Base 64 encoded</a>. I&rsquo;m no expert
with OpenSSL, but following a few examples I came up with:</p>

<pre><code class="c">static char *base64_encode(const char *msg, size_t msg_len)
{
    /* This could be improved. Currently it allocates bit too much. Times three
     * is required for the percent encoding but times four is just overestimate
     * of base64 encoding. */
    size_t signature_len = msg_len * 4 * 3 + 1;

    char *encoded = malloc(signature_len);
    if (encoded == NULL) {
        return NULL;
    }

    /* From https://www.openssl.org/docs/crypto/BIO_f_base64.html */
    BIO *b64 = BIO_new(BIO_f_base64());
    if (b64 == NULL) {
        free(encoded);
        return NULL;
    }

    /* Bio base64 writes to a stream for some reason, so open a stream to the
     * buffer. */
    FILE *stream = fmemopen(encoded, signature_len, "w");
    if (stream == NULL) {
        free(encoded);
        BIO_free_all(b64);
        return NULL;
    }

    BIO *bio = BIO_new_fp(stream, BIO_NOCLOSE);
    BIO_push(b64, bio);
    BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
    BIO_write(b64, msg, (int)msg_len);
    BIO_flush(b64);

    BIO_free_all(b64);
    fclose(stream);

    return encoded;
}
</code></pre>

<h2>5. Create the signature</h2>

<p>Twitter users OAuth and HTTPS for its APIs. This is already documented quite
nicely in
<a href="https://dev.twitter.com/oauth/overview/creating-signatures">Creating Signatures</a>,
so I won&rsquo;t repeat everything here.</p>

<p>First you&rsquo;ll need a nonce that is used in the signature. It should be relatively
random and you shouldn&rsquo;t use a nonce twice (even for prototyping). If you are
using OpenSSL, you could do something like this:</p>

<pre><code class="c">/* Generate nonce used as oauth_nonce. */
static char *generate_nonce(void)
{
    char nonce[32];

    if (!RAND_bytes((unsigned char *)nonce, sizeof(nonce))) {
        return NULL;
    }

    char *encoded_nonce = base64_encode(nonce, sizeof(nonce));
    if (encoded_nonce == NULL) {
        return NULL;
    }

    size_t nonce_len = strlen(encoded_nonce);
    for (size_t i = 0; i &lt; nonce_len; i++) {
        if (!isalnum((int)encoded_nonce[i])) {
            /* Replace non-alphanumerics by arbitrary 'a' since they should not
             * be present in the nonce. */
            encoded_nonce[i] = 'a';
        }
    }

    return encoded_nonce;
}
</code></pre>

<p>Nonce shouldn&rsquo;t have any non-alphanumeric characters, but maybe you can figure out nicer
way to get rid of those yourself.</p>

<p>Signature also expects a timestamp, but that can be retrieved quite easily with
time(2):</p>

<pre><code class="C">time_t t = time(NULL);
char timestamp[11];
snprintf(timestamp, sizeof(timestamp), "%zu", (size_t)t);
</code></pre>

<p>Now we should have all the parameters for the signature. Next we have to hash
it with
<a href="http://en.wikipedia.org/wiki/Hash-based_message_authentication_code">HMAC-SHA1</a>.</p>

<p>One simple implementation of that using OpenSSL would be:</p>

<pre><code class="c">static unsigned char *hmac_sha1_encode(const char *data, const char *hmac_key,
                                       unsigned int *result_len)
{
    *result_len = 20; /* Should be always 20 bytes. */
    unsigned char *result = malloc(*result_len);
    if (result == NULL) {
        return NULL;
    }

    HMAC_CTX ctx;

    /* Example from http://stackoverflow.com/a/245335. */
    HMAC_CTX_init(&amp;ctx);
    HMAC_Init_ex(&amp;ctx, hmac_key, (int)strlen(hmac_key), EVP_sha1(), NULL);
    HMAC_Update(&amp;ctx, (const unsigned char *)data, strlen(data));
    HMAC_Final(&amp;ctx, result, result_len);
    HMAC_CTX_cleanup(&amp;ctx);

    return result;
}
</code></pre>

<p>Now we are ready to build the signature:</p>

<pre><code class="c">/* Compute the signature from given parameters as required by the OAuth. */
static char *compute_signature(const char *timestamp, const char *nonce, const char *status,
                               const char *consumer_key, const char *auth_token,
                               const char *hmac_key)
{
    char *signature_base = malloc(buf_size);
    if (signature_base == NULL) {
        return NULL;
    }

    /* Encode the status again. */
    char encoded_status[strlen(status) * 3 + 1];
    snprintf(encoded_status, sizeof(encoded_status), "%s", status);
    percent_encode(encoded_status);

    int ret = snprintf(signature_base, buf_size, "POST&amp;https%%3A%%2F%%2Fapi.twitter.com"
                       "%%2F1.1%%2Fstatuses%%2Fupdate.json&amp;"
                       "oauth_consumer_key%%3D%s%%26oauth_nonce%%3D%s"
                       "%%26oauth_signature_method%%3DHMAC-SHA1"
                       "%%26oauth_timestamp%%3D%s%%26oauth_token%%3D%s"
                       "%%26oauth_version%%3D1.0"
                       "%%26status%%3D%s",
                       consumer_key, nonce, timestamp, auth_token, encoded_status);
    if (ret &lt; 0 || (size_t)ret &gt; buf_size) {
        free(signature_base);
        return NULL;
    }

    unsigned int encoded_len;
    char *hmac_encoded = (char *)hmac_sha1_encode(signature_base, hmac_key,
                                                  &amp;encoded_len);
    free(signature_base);

    if (hmac_encoded == NULL) {
        return NULL;
    }

    char *encoded = base64_encode(hmac_encoded, encoded_len);
    free(hmac_encoded);

    if (encoded == NULL) {
        return NULL;
    }

    return percent_encode(encoded);
}
</code></pre>

<p>The parameters should be quite self-explanatory expect the HMAC key. HMAC key is
formed from the consumer secret and access token secret by concatenating them with
<code>&amp;</code>. For example, HMAC key in our example would be simply:</p>

<pre><code>kAcSOqF21Fu85e7zjz7ZN2U4ZRhfV3WpwPAoE3Z7kBw&amp;LswwdoUaIvS8ltyTt5jkRh4J50vUPVVHtR2YPi5kE
</code></pre>

<p>You should note that parameter <code>status</code> is already percent-encoded once, but for
the signature it should be encoded again.</p>

<p>After these, we need to build our <code>signature_base</code>. It should have the HTTP
request method (here <code>POST</code>), URL that we are going to use
(<code>https://api.twitter.com/1.1/statuses/update.json</code>) and then the parameters
(extra <code>%</code> comes from escaping percent in printf). For more information, see
<a href="https://dev.twitter.com/oauth/overview/creating-signatures">Creating Signatures</a>.</p>

<p>Now we should have everything and we can do the HMAC-SHA1 hashing. The hash
should finally be base64- and percent-encoded and then we have our signature that
we will use in our HTTP POST.</p>

<h2>6. Create the POST</h2>

<p>Next we have to create the POST, but we should now have all parameters for that
so it should be easy.</p>

<p>We are posting a status update and the API documentation for that can be found
<a href="https://dev.twitter.com/rest/reference/post/statuses/update">here</a>. In short,
the URL is <code>https://api.twitter.com/1.1/statuses/update.json</code> and the only
required parameter is <code>status</code>. Example of updating status can be found
<a href="https://dev.twitter.com/oauth/overview/authorizing-requests">here</a>.</p>

<pre><code class="c">static char *create_post(const char *timestamp, const char *nonce, const char *status,
                         const char *signature, const char *consumer_key,
                         const char *auth_token)
{
    char *post = malloc(buf_size);
    if (post == NULL) {
        return NULL;
    }

    int ret = snprintf(post, buf_size, "POST /1.1/statuses/update.json HTTP/1.1\r\n"
                       "User-Agent: LightBot\r\n"
                       "Host: api.twitter.com\r\n"
                       "Content-Type: application/x-www-form-urlencoded\r\n"
                       "Authorization: OAuth oauth_consumer_key=\"%s\", oauth_nonce=\"%s\", "
                       "oauth_signature=\"%s\", oauth_signature_method=\"HMAC-SHA1\", "
                       "oauth_timestamp=\"%s\", oauth_token=\"%s\", oauth_version=\"1.0\"\r\n"
                       "Content-Length: %zu\r\n\r\n"
                       "status=%s",
                       consumer_key, nonce, signature, timestamp, auth_token,
                       strlen("status=") + strlen(status), status);
    if (ret &lt; 0 || (size_t)ret &gt;= buf_size) {
        free(post);
        return NULL;
    }

    return post;
}
</code></pre>

<p>The main &lsquo;new&rsquo; thing here is the <code>Authorization</code> parameter which is required by the
OAuth. Otherwise it&rsquo;s quite straightforward: HTTP method, URL, protocol version,
user agent (which is just the name of the application) etc.</p>

<h2>7. Sending</h2>

<p>Only thing left is to open a SSL connection to twitter, send the POST and check
the result. A crude example of doing so:</p>

<pre><code class="c">/**
 * Posts given POST to api.twitter.com.
 *
 * From https://thunked.org/programming/openssl-tutorial-client-t11.html and
 * example in https://www.openssl.org/docs/crypto/BIO_f_ssl.html.
 *
 * This doesn't verify the server certificate, i.e. it will accept certificates
 * signed by any CA.
 */
static int send_to_twitter(const char *post)
{
    SSL_CTX* ctx = SSL_CTX_new(SSLv23_client_method());
    if (ctx == NULL) {
        printf("Error creating SSL_CTX\n");
        return -1;
    }

    BIO* bio = BIO_new_ssl_connect(ctx);
    if (bio == NULL) {
        printf("Error creating BIO!\n");
        SSL_CTX_free(ctx);
        return -1;
    }

    SSL* ssl;
    BIO_get_ssl(bio, &amp;ssl);
    if (ssl == NULL) {
        printf("BIO_get_ssl failed\n");
        BIO_free_all(bio);
        SSL_CTX_free(ctx);
        return -1;
    }

    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
    BIO_set_conn_hostname(bio, "api.twitter.com:https");

    if (BIO_do_connect(bio) &lt;= 0) {
        printf("Failed to connect!");
        BIO_free_all(bio);
        SSL_CTX_free(ctx);
        return -1;
    }

    if (BIO_do_handshake(bio) &lt;= 0) {
        printf("Failed to do SSL handshake!");
        BIO_free_all(bio);
        SSL_CTX_free(ctx);
        return -1;
    }

    int ret;

    char buf[1024] = { 0 };
    BIO_puts(bio, post);

    int read_bytes = BIO_read(bio, buf, sizeof(buf) - 1);
    if (read_bytes &gt; 0) {
        buf[read_bytes] = '\0';

        if (strstr(buf, "HTTP/1.1 200 OK") != NULL) {
            ret = 0;
        } else if (strstr(buf, "HTTP/1.1 403 Forbidden") != NULL) {
            /* Twitter doesn't allow consecutive duplicates and will respond
             * with 403 in such case. */
            printf("Twitter responded with 403!\n");
            ret = -2;
        } else {
            printf("Error occurred! Received:\n"
                   "%s\n", buf);
            ret = -1;
        }
    } else {
        printf("Read failed!\n");
        ret = -1;
    }

    BIO_free_all(bio);
    SSL_CTX_free(ctx);

    return ret;
}
</code></pre>

<p>Interesting return codes here are 200 and 403. Former will be sent if the update
was successful, but the latter will be sent if we have reached rate limit or send
a duplicate update as seen in the description of the API.</p>

<p>Now you should have your tweet posted on your account! As always, the full code
can be found <a href="https://bitbucket.org/aatos/twitter-update/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sockets in C]]></title>
    <link href="https://www.aatosjalo.com/blog/2014/07/14/sockets-in-c/"/>
    <updated>2014-07-14T16:17:33+03:00</updated>
    <id>https://www.aatosjalo.com/blog/2014/07/14/sockets-in-c</id>
    <content type="html"><![CDATA[<p>It has been a while since I have done anything with sockets in C, so I figured I
should refresh my
memory. <a href="http://beej.us/guide/bgnet/output/html/singlepage/bgnet.html">Beej</a>
already has a great guide to network programming, so I&rsquo;ll try to make a very
simple and small introduction. If you want to know more, you should refer to his
guide.</p>

<!-- more -->


<p>To be able to send (or receive) something through sockets, you need perform
at least two steps:</p>

<ol>
<li>Create a socket with <a href="http://linux.die.net/man/3/socket">socket(3)</a>.</li>
<li>Attach an address to it by:

<ul>
<li>binding (<a href="http://linux.die.net/man/3/bind">bind(3)</a>) a local address to it (if you are
the server),</li>
<li>or connecting (<a href="http://linux.die.net/man/3/connect">connect(3)</a>) it to a destination
address (usually as a client).</li>
</ul>
</li>
</ol>


<p>In addition to these, you have to perform other steps if you are the server:</p>

<ol>
<li>Allow the socket to receive incoming connections by using <a href="http://linux.die.net/man/3/listen">listen(3)</a></li>
<li>and finally wait for a new client with <a href="http://linux.die.net/man/3/accept">accept(3)</a>.</li>
</ol>


<p>After these are successfully completed, you can use
<a href="http://linux.die.net/man/3/recv">recv(3)</a> and
<a href="http://linux.die.net/man/3/send">send(3)</a> to interact with the remote end. The
steps above are valid for TCP sockets; with UDP you don&rsquo;t have to do all of them
since it uses connectionless communication. After the communication is done, you
should close the socket using <a href="http://linux.die.net/man/3/close">close(3)</a>.</p>

<p>Let&rsquo;s start by creating a socket for a client application. The prototype is:</p>

<pre><code class="c socket function prototype">    int socket(int domain, int type, int protocol);
</code></pre>

<p>where <code>domain</code> is basically <code>AF_INET</code> for IPv4 connections and <code>AF_INET6</code> for
IPv6, <code>type</code> is <code>SOCK_STREAM</code> for TCP connections and <code>SOCK_DGRAM</code> for UDP. By
leaving <code>protocol</code> to <code>0</code>, we say that we support only one protocol family and
protocol is then deduced from the <code>domain</code>. Naturally there are more options
than these and you can read more from the man-pages. The return value is a file
descriptor to newly created socket (in a successful case). So to create an IPv4
socket for TCP communication, we could do:</p>

<pre><code class="c">    int sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (sock_fd &lt; 0) {
        perror("socket failed");
        return -1;
    }
</code></pre>

<p>Now we need to assign an address to the socket by using <code>bind</code> or <code>connect</code>,
which are pretty similar to each other:</p>

<pre><code class="c bind and connect function prototypes">    int bind(int sockfd, const struct sockaddr *addr,
             socklen_t addrlen);

    int connect(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
</code></pre>

<p>Here the <code>sockfd</code> is the file descriptor returned by the <code>socket</code>, <code>addr</code> is a
pointer to an address in the network format and <code>addrlen</code> is its length. In both
cases return value is zero on success and <code>-1</code> on error.</p>

<p>You would basically have your IP address as a string, e.g. <code>"127.0.0.1"</code> which
is in printable format. To get a network format from that, you would most likely
use function like <a href="http://linux.die.net/man/3/inet_pton">inet_pton(3)</a>:</p>

<pre><code class="c inet_pton function prototype">    int inet_pton(int af, const char *src, void *dst);
</code></pre>

<p>With <code>inet_pton</code> you transform printable (<strong><em>p</em></strong>ton) address to network address
format (pto<strong><em>n</em></strong>), for example like this:</p>

<pre><code class="c">    struct sockaddr_in sock_addr = {0};
    int ret = inet_pton(AF_INET, "127.0.0.1", &amp;sock_addr.sin_addr);
    if (ret != 1) {
        fprintf(stderr, "inet_pton failed: %d\n", ret);
        return -1;
    }
</code></pre>

<p>Then after setting the port (using <code>6000</code> as an example) and the family (IPv4),</p>

<pre><code class="c">    sock_addr.sin_family = AF_INET;
    sock_addr.sin_port = htons(6000);
</code></pre>

<p>you could connect the previously created <code>sock_fd</code> to the destination address:</p>

<pre><code class="c">    ret = connect(sock_fd, (const struct sockaddr *)&amp;sock_addr, sizeof(sock_addr));
    if (ret &lt; 0) {
        perror("connect failed");
        close(sock_fd);
        return -1;
    }
</code></pre>

<p>Now that the socket is created and connected to the destination address, we
can send something (with <a href="http://linux.die.net/man/3/send">send(3)</a>):</p>

<pre><code class="c send function prototype">ssize_t send(int socket, const void *buffer, size_t length, int flags);
</code></pre>

<p>Here <code>socket</code> is the <code>sock_fd</code> that we have connected, <code>buffer</code> contains the
message to be sent and <code>length</code> is its length in bytes. <code>flags</code> argument is not
interesting for us, so we can leave it as <code>0</code>. <code>send</code> will return the number of
bytes sent or <code>-1</code> on failure. But basically it will either send all the bytes
or fail with <code>-1</code>, so you can just check that the return value is not negative.</p>

<pre><code class="c">    const char buf[] = "test string";

    ssize_t sent_bytes = send(sock_fd, buf, sizeof(buf), 0);
    if (sent_bytes &lt; 0) {
        perror("send failed");
        close(sock_fd);
        return -1;
    }
</code></pre>

<p>To create the server application, we will create the socket same way as before
but now we will use <code>bind</code> instead of <code>connect</code>.</p>

<pre><code class="c">    int sock_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (sock_fd &lt; 0) {
        perror("socket failed");
        return -1;
    }

    struct sockaddr_in sock_addr = {0};
    sock_addr.sin_family = AF_INET;
    sock_addr.sin_addr.s_addr = INADDR_ANY;
    sock_addr.sin_port = htons(6000);

    int ret = bind(sock_fd, (const struct sockaddr *)&amp;sock_addr, sizeof(sock_addr));
    if (ret &lt; 0) {
        perror("bind failed");
        close(sock_fd);
        return -1;
    }
</code></pre>

<p>We use constant <code>INADDR_ANY</code> as an address to say that we want to bind to all
interfaces on the machine (i.e. not restricting us only to &ldquo;127.0.0.1&rdquo; but to
allow packets to arrive in any address assigned to us). Next we have to inform
the operating system that we are interested in incoming connections by using
<code>listen</code>:</p>

<pre><code class="c listen function prototype">int listen(int socket, int backlog);
</code></pre>

<p>Here <code>socket</code> is the socket file descriptor that we have bound and <code>backlog</code> is
basically means how many clients there can be queued for this socket. We are
expecting only one client now so let&rsquo;s just use <code>1</code> as a <code>backlog</code>. <code>listen</code>
returns <code>0</code> on success and <code>-1</code> on failure, so remember to check the return
value also here.</p>

<pre><code class="c">    ret = listen(sock_fd, 1);
    if (ret &lt; 0) {
        perror("listen failed");
        close(sock_fd);
        return -1;
    }
</code></pre>

<p>The actual waiting for a new client happens in <code>accept</code>:</p>

<pre><code class="c accept function prototype">int accept(int socket, struct sockaddr *restrict address,
           socklen_t *restrict address_len);
</code></pre>

<p>Here <code>socket</code> is the file descriptor that has been bound and listened, <code>address</code>
is a structure where the address of connected client is stored and <code>address_len</code>
is its length. Last two arguments are optional, so if you are not interested in
client&rsquo;s address, you may just give <code>NULL</code> to both. Return value is a socket
file descriptor or <code>-1</code> on failure. Notice though that <code>accept</code> will block until
a client arrives, meaning that this function call will not return until someone
connects to our server.</p>

<pre><code class="c">        int client_sock = accept(sock_fd, NULL, NULL);
        if (client_sock &lt; 0) {
            perror("accept failed");
            close(sock_fd);
            return -1;
        }
</code></pre>

<p>Now we can use <code>client_sock</code> for sending and receiving. Since our client program
sends a message to the server, we might as well use <code>recv</code> here and print the
received bytes:</p>

<pre><code class="c recv function prototype">ssize_t recv(int socket, void *buffer, size_t length, int flags);
</code></pre>

<p><code>recv</code> function prototype is basically the same as with <code>send</code>. <code>flags</code> can be
omitted also here for now. Only difference is the return value; <code>recv</code> will
return the length of the message received, <code>-1</code> on failure or <code>0</code> if client has
properly closed the socket. So if zero is returned, client didn&rsquo;t send anything.</p>

<pre><code class="c">        char buf[1024];

        ssize_t received_bytes = recv(client_sock, buf, sizeof(buf), 0);
        if (received_bytes &lt; 0) {
            perror("recv failed");
            close(client_sock);
            close(sock_fd);
            return -1;
        } else if (received_bytes == 0) {
            fprintf(stderr, "client closed the connection\n");
        } else {
            /* Someting was received, print it. */
            printf("received: '");
            for (ssize_t i = 0; i &lt; received_bytes; i++) {
                putchar(buf[i]);
            }
            printf("'\n");
        }

        close(client_sock);
        close(sock_fd);
</code></pre>

<p>And that&rsquo;s all there is to get a simple client/server application in C. Remember
to check the return values and print errors with
<a href="http://linux.die.net/man/3/perror">perror(3)</a> if you run in to any problems. As
always, you can download the complete files for the
<a href="https://aatosjalo.com/downloads/code/client.c">client</a> and the
<a href="https://aatosjalo.com/downloads/code/server.c">server</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Boyer-Moore]]></title>
    <link href="https://www.aatosjalo.com/blog/2014/06/30/understanding-boyer-moore/"/>
    <updated>2014-06-30T20:21:25+03:00</updated>
    <id>https://www.aatosjalo.com/blog/2014/06/30/understanding-boyer-moore</id>
    <content type="html"><![CDATA[<p>Boyer-Moore string searching algorithm is very elementary string searching
algorithm that is probably gone through as a first or second algorithm in every
string algorithm course. Even though it is a basic algorithm, it doesn&rsquo;t mean
that it wouldn&rsquo;t be used in any real-world application. For example, Boyer-Moore
is used in GNU Grep for fixed string matching <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> and also in <a href="https://github.com/ggreer/the_silver_searcher">Silver Surfer</a> (well, both use a
different BM variant but still BM).</p>

<!-- more -->


<p>BM starts comparing characters one by one starting from the last character in
the pattern. By comparing each character we don&rsquo;t get much better performance
than a trivial algorithm, so BM tries to minimize the character comparisons and
not to do any pointless comparisons. Character comparisons can be minimized by
shifting the pattern to the right when a mismatch occurs. By starting the
comparison from the last character, algorithm can learn more about matched and
mismatched characters.</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern: ABBABAB
               ↑
</code></pre>

<p>So here the text is <code>ABBABAZ AABBABAB ABACBCBBABAB</code> and the pattern that we are
searching from the text is <code>ABBABAB</code>. The character that the algorithm is
currently comparing is pointed by the <code>↑</code>. Character <code>Z</code> doesn&rsquo;t occur in the
pattern, and if the last character doesn&rsquo;t match, there is no point in comparing
any of the preceding characters, so pattern can shifted fully past the <code>Z</code>
character.</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern:        ABBABAB
                      ↑
</code></pre>

<p>The amount BM shifts the pattern forward is calculated by two rules: bad
character rule and good suffix rule. We saw the bad character rule already in
the previous example. It tells how much the pattern can be shifted given a
character that caused the mismatch. Bad character rule produces a table
consisting of all possible characters that can occur in the text. Each element
tells how much pattern can be shifted when this character caused the
mismatch. Characters that are not in the pattern, e.g. <code>Z</code> in this case, have
the length of the pattern as the value. Characters that occur in the pattern
have the value of distance from the end of the pattern to the rightmost
occurrence. If the distance is <code>0</code>, algorithm would still shift it by <code>1</code> since
otherwise we would stay at the same place indefinitely. For example, <code>A</code> would
have a value of <code>1</code> since it is the second character from the end. The full
table for this pattern would be:</p>

<pre><code>Character:    A B Other
Value:        1 0 7
</code></pre>

<p>Good suffix rule is a bit more complex. It focuses on the already matched
characters (i.e. the suffix that was successfully matched). It consists of two
cases. First, it tries to align matched suffix to another occurrence of it in the
pattern (preceded by a different character) and if this is not possible, it
tries to align a suffix of the matched part and a prefix of the pattern. Coming
back to the previous example.</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern:        ABBABAB
                   ↑
</code></pre>

<p>At this point, <code>BAB</code> is the suffix that is successfully matched since a mismatch
happens when comparing <code>B</code> to <code>A</code>. Bad character shift would be now <code>1</code> (table
says <code>0</code> but we&rsquo;ll really shift by <code>1</code>), but with good suffix rule we could
shift more. If there is another occurrence of the matched suffix somewhere else
in the pattern, that occurrence is aligned to the same substring in the text. But
since we don&rsquo;t want to do a pointless shift and end up in the same situation
(i.e. successfully match <code>BAB</code> but then fail when comparing <code>B</code> to <code>A</code>), we need
to check that this occurrence is not preceded by the same character that the
matched suffix was. In our case, <code>BAB</code> is preceded by <code>A</code>, so now we want to
find <code>BAB</code> somewhere else in the pattern which preceded by something else. <code>BAB</code>
occurs only in &lsquo;ABBA<strong><em>BAB</em></strong>&rsquo; and &lsquo;AB<strong><em>BAB</em></strong>AB&rsquo; which are both preceded by
different characters. So the pattern is aligned as follows:</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern:          ABBABAB
                        ↑
</code></pre>

<p>Now the pattern is matched and we end up in a situation like this:</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern:          ABBABAB
                 ↑
</code></pre>

<p>Again, bad character shift would be <code>1</code>. Now the good suffix is <code>ABBABAB</code>,
i.e. the whole pattern but it cannot occur anywhere else in the pattern. But
according to the second case in good suffix rule, we will try to align a suffix
of the matched part and a prefix of the pattern. <code>AB</code> is both prefix and suffix
of <code>ABBABAB</code> so we will align &lsquo;<strong><em>AB</em></strong>BABAB&rsquo; and &lsquo;ABBAB<strong><em>AB</em></strong>&rsquo;.</p>

<pre><code>text:    ABBABAZ AABBABAB ABACBCBBABAB
pattern:               ABBABAB
                             ↑
</code></pre>

<p>So, we have two rules in BM and neither of them will miss any of the
occurrences. Sometimes bad character rule can shift more than good suffix rule
and sometimes vice versa. Hence, it is more efficient to calculate the shift
from both rules and use the maximum. It would be possible to only implement the
other and still be able to match all possible occurrences.</p>

<p>Implementation of the main BM algorithm is quite straightforward. As said
before, BM compares characters one by one starting from the end of the pattern
and shifts it according to the two rules when mismatch occurs.</p>

<pre><code class="c">uint32_t boyer_moore(const char *text, const char *pattern)
{
    uint32_t matches = 0;

    const size_t pattern_len = strlen(pattern);
    const size_t text_len = strlen(text);

    uint32_t bad_char[ALPHABET_SIZE];
    uint32_t good_suffix[pattern_len + 1];

    build_bad_char_array(bad_char, pattern, pattern_len);
    build_good_suffix_array(good_suffix, pattern, pattern_len);

    for (uint32_t i = pattern_len - 1; i &lt; text_len;)
    {
        uint32_t j = pattern_len - 1;
        while (text[i] == pattern[j]) {
            if (j == 0) {
                printf("match %u at %d\n", matches, i);
                matches++;
                break;
            }
            i--;
            j--;
        }

        const uint32_t matched_chars = pattern_len - 1 - j;
        const uint32_t delta1 = bad_char[text[i]] &lt;= matched_chars ?
            1 : bad_char[text[i]] - matched_chars;
        const uint32_t delta2 = good_suffix[j + 1];

        const uint32_t shift = MAX(delta1, delta2);

        i += matched_chars + shift;
    }

    return matches;
}
</code></pre>

<p>This function runs BM algorithm on a given text and pattern, prints positions
where matches occur and returns the number of the matches. The first few lines
initialize the structures and calculate lengths of the pattern and the text
(which could be omitted). Then at the for loop, we start looping through the
characters, starting from the end of the pattern and continuing until we have
gone through the whole text. The while loop compares the characters in the text and
in the pattern until a mismatch occurs (or until we have successfully matched
each character so we have a match). After that the position where we read from
the text is shifted according to the two rules.</p>

<p>One thing to note though is that when calculating shift from bad character
rule, we must take number of matched characters into account. For example, if
the situation is:</p>

<pre><code>text:    ABBAZABBABAB
pattern: ABBABAB
             ↑
</code></pre>

<p>Value in the bad character shift table would be 7, which would be invalid since
valid match would not be seen. Hence we have to subtract matched characters
from 7, i.e. actual shift would be 5 and next place for the pattern is:</p>

<pre><code>text:    ABBAZABBABAB
pattern:      ABBABAB
                    ↑
</code></pre>

<p>In addition, when calculating the shift from bad character rule (<code>delta1</code>), we
have to make sure that if <code>bad_char[text[i]]</code> is zero, we shift it with 1.</p>

<p>As you can see, the main logic is very simple and it can be done in a few lines
of code. Some error checks here are omitted for simplicity, for example,
checking that pattern and text are nonempty and non-null and that the pattern is
not shorter than the text, but they would be very trivial to add.</p>

<pre><code class="c">void build_bad_char_array(uint32_t *bad_char_array, const char *pattern,
                          const size_t pattern_len)
{
    for (uint32_t i = 0; i &lt; ALPHABET_SIZE; i++) {
        bad_char_array[i] = pattern_len;
    }

    for (uint32_t i = 0; i &lt; pattern_len; i++) {
        bad_char_array[pattern[i]] = pattern_len - i - 1;
    }
}
</code></pre>

<p>Let&rsquo;s move on to the bad character rule. The first for loop initializes the
whole bad character array with the length of the pattern. This way we can
address the characters that are not in the pattern. To recap, if the character
in the text doesn&rsquo;t occur anywhere in the pattern, we can move the whole pattern
past that. <code>ALPHABET_SIZE</code> should cover all possible characters in text. Here we
are using <code>CHAR_MAX</code> which should be enough when dealing with ASCII text.</p>

<p>The second for loop in bad character rule sets the characters that are actually
in the pattern. In a case of a mismatch, when the character is in the pattern,
we must shift the pattern so that the character in the text and the
corresponding character in the pattern are aligned. If there are many occurrences
of that character in the pattern, we should align with the rightmost.</p>

<pre><code class="c">void build_good_suffix_array(uint32_t *good_suffix_array, const char *pattern,
                             const size_t pattern_len)
{
    /* If the mismatch happens at the first character, we can only move by
     * one. */
    good_suffix_array[pattern_len] = 1;
    /* Case 1 doesn't apply on the first element, so initialize it to zero. */
    good_suffix_array[0] = 0;

    build_good_suffix_case1(good_suffix_array, pattern, pattern_len);
    build_good_suffix_case2(good_suffix_array, pattern, pattern_len);
}
</code></pre>

<p>Only thing left now is the good suffix rule which is also arguably the most
difficult part. Easiest (but not the most efficient) way to tackle this is to
simply turn the both cases to code. At first, we have few corner cases: if a
mismatch happens on the first character, we can only shift by one since we don&rsquo;t
really know anything about the text yet. Secondly, since <code>good_suffix_rule</code> is
not initialized, we should set zeroth element to zero since case 1 cannot apply
to it. Then we build case 1 and case 2 of the good suffix rule.</p>

<p>First case in good suffix rule is to find the matched part somewhere else in the
pattern, but it cannot have the same preceding character as the matched
part. Easiest way to do this is to search all possible suffixes from the
pattern.</p>

<pre><code class="c">static void build_good_suffix_case1(uint32_t *good_suffix_array, const char *pattern,
                                    const size_t pattern_len)
{
    /* Case 1: matched string occurs in the pattern. */
    for (uint32_t i = 1; i &lt; pattern_len; i++) {
        uint32_t matched_start_idx = pattern_len - i;
        int m = find_occurrence(pattern, matched_start_idx,
                                pattern + matched_start_idx, i,
                                pattern[matched_start_idx - 1]);
        if (m &gt;= 0) {
            good_suffix_array[pattern_len - i] = matched_start_idx - m;
        } else {
            good_suffix_array[pattern_len - i] = 0;
        }
    }
}
</code></pre>

<p>So, start searching the occurrences of the suffixes. For example, if the pattern
is <code>abbabab</code>, we&rsquo;ll search occurrences of <code>b</code>, then <code>ab</code>, <code>bab</code>, <code>abab</code> and so
on. For <code>b</code>, you&rsquo;ll find occurrences in &lsquo;a<strong><em>b</em></strong><strong><em>b</em></strong>a<strong><em>b</em></strong>a<strong><em>b</em></strong>&rsquo;, but it
may not be preceded by <code>a</code> (because <code>a</code> is now the character that caused the
mismatch and shifting with that would bring us to the same situation) and the
rightmost <code>b</code> doesn&rsquo;t count (because shift would be 0 which would be
nonsense). Hence, the correct occurrence is &lsquo;ab<strong><em>b</em></strong>abab&rsquo;. When building case 1
for good suffix rule, we feed all these suffixes to <code>find_occurrence</code> function.</p>

<pre><code class="c">static int find_occurrence(const char *haystack, const size_t comparison_start,
                           const char *needle, const size_t needle_len,
                           const char preceding)
{
    for (int i = comparison_start - 1; i &gt;= 0; i--) {
        int match = strncmp(haystack + i, needle, needle_len);
        if (match == 0) {
            if (i == 0 || haystack[i - 1] != preceding) {
                return i;
            }
        }
    }
    return -1;
}
</code></pre>

<p>Here we try to find the given suffix somewhere from the pattern. It basically
tries to be reverse <code>strstr</code>, because we are interested in the rightmost
match. In addition, the match may not be preceded by the mismatched character
(parameter <code>preceding</code>). For example, when calculating good suffix rule for
<code>bab</code>, where <code>b</code> is the mismatched character so the good suffix is <code>ab</code>, this
function makes following comparisons:</p>

<pre><code>text:    abbabab
pattern:     ab    # 'ba' != 'ab'
            ab     # 'ab' == 'ab', but preceded by 'b'
           ab      # 'ba' != 'ab'
          ab       # 'bb' != 'ab'
         ab        # 'ab' == 'ab', and not preceded by 'b' -&gt; return 0
</code></pre>

<p>Last part of the good suffix rule should check if a suffix of the matched
substring is a prefix of the pattern. In other words, check if some rightmost
part of the matched substring is included at the beginning of the pattern. This
case doesn&rsquo;t apply if previous case applied, so if <code>good_suffix_rule[i]</code> is
nonzero, we don&rsquo;t have to calculate anything there. One simple way to implement
this, it is to take each suffix and check if ending of it occurs at the
beginning of the pattern.</p>

<pre><code class="c">static void build_good_suffix_case2(uint32_t *good_suffix_array, const char *pattern,
                                    const size_t pattern_len)
{
    /* Case 2: suffix of a matched string is a prefix of the pattern. */
    for (uint32_t i = 0; i &lt; pattern_len; i++) {
        if (good_suffix_array[i] != 0) {
            /* If case 2 is applies only if case 1 didn't. */
            continue;
        }

        int m = is_prefix(pattern, pattern + i, pattern_len - i);
        if (m &gt; 0) {
            good_suffix_array[i] = i + m;
        } else {
            good_suffix_array[i] = pattern_len;
        }
    }
}
</code></pre>

<p>In <code>build_good_suffix_case2</code> function, we take each suffix and give it to
<code>is_prefix</code> function. This time the order of the suffixes doesn&rsquo;t matter so
we&rsquo;ll start looping from the left.</p>

<pre><code class="c">static int is_prefix(const char *str, const char *prefix,
                     const uint32_t prefix_len)
{
    uint32_t i = 0;

    /* Prefix must be a proper prefix, so if str and prefix are the same then
     * start comparing from the first character. */
    if (str == prefix) {
        i = 1;
    }

    for (; i &lt; prefix_len; i++) {
        int match = strncmp(str, prefix + i, prefix_len - i);
        if (match == 0) {
            return i;
        }
    }

    return -1;
}
</code></pre>

<p>Here we start checking if <code>str</code> and <code>prefix</code> are the same memory address,
because we are interested only in proper prefixes (proper prefix is not the
string itself). Since we know how this function is used, we may use memory
address comparison here. Then we start decreasing <code>prefix</code> from the right until
it matches or until all suffixes are checked. For example, when <code>str</code> is the
same <code>ABBABAB</code>, and <code>prefix</code> is <code>BBABAB</code>, following comparisons are made:</p>

<pre><code>str:     abbabab
prefix:  bbabab
         babab
         abab
         bab
         ab        # match -&gt; return '4'
</code></pre>

<p>This implementation of the good suffix rule is quite inefficient since we
discard a lot of information, e.g. we would only need to calculate possible
suffixes once and we could learn those already when calculating the first
case. But since we are trying to understand how BM works, I think this approach
is justified since it is easier to understand.</p>

<p>You can find the whole implementation
<a href="https://aatosjalo.com/downloads/code/bm.c">here</a> with few unit tests. It should
print something like this:</p>

<pre><code class="bash">$ gcc -std=c99 -Wall -Wextra -pedantic -Wno-char-subscripts bm.c &amp;&amp; ./a.exe
searching 'bar' from 'foo'
searching 'foo' from 'fo'
searching 'fooooo' from 'foooob'
searching 'foo' from 'foo'
match 0 at 0
searching 'foo' from 'barfoo'
match 0 at 3
searching 'foobar' from 'barfoo rfoobarr foobar'
match 0 at 8
match 1 at 16
searching 'foobar' from 'foobafoobafoobafoobafrboofarfoobar'
match 0 at 28
searching 'WOOHOO' from 'HOOWOOWOOHOOWOOWOO'
match 0 at 6
searching 'LALLILLA' from 'SALLILAILLATAVANLALLILLALLALALLI'
match 0 at 16
</code></pre>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>http://git.savannah.gnu.org/cgit/grep.git/tree/README<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
